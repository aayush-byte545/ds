#include <stdio.h>
#include <stdlib.h>

// Define a node structure
struct Node {
    int data;           // Data part of the node
    struct Node* next;  // Pointer to the next node
};

// Function to create a new node
struct Node* createNode(int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (!newNode) {
        printf("Memory allocation failed!\n");
        exit(1); // Exit if memory allocation fails
    }
    newNode->data = value; // Set the node's data
    newNode->next = newNode;  // Point to itself to form a circular link
    return newNode;        // Return the created node
}

// Function to insert a node at the end of the circular linked list
void insertAtEnd(struct Node** head, int value) {
    struct Node* newNode = createNode(value); // Create a new node

    // If the list is empty, initialize it with the new node
    if (*head == NULL) {
        *head = newNode; // Point head to the new node
    } else {
        struct Node* temp = *head; // Temporary pointer to find the last node

        // Traverse to the last node
        while (temp->next != *head) {
            temp = temp->next; // Move to the next node
        }
        
        // Point the last node's next to the new node
        temp->next = newNode; // Link last node to the new node
    }
    
    // Link the new node back to the head to maintain circularity
    newNode->next = *head; // Complete the circular link
}

// Function to delete a node at a specific location in the circular linked list
void deleteAtPosition(struct Node** head, int position) {
    if (*head == NULL) {
        printf("The list is empty. Deletion failed.\n");
        return;
    }

    struct Node* temp = *head; // Temporary pointer to traverse the list

    // If the node to be deleted is the head node
    if (position == 0) {
        // If there is only one node in the list
        if (temp->next == *head) {
            free(temp); // Free the only node
            *head = NULL; // Update head to NULL
        } else {
            // Find the last node
            struct Node* last = *head;
            while (last->next != *head) {
                last = last->next; // Move to the next node
            }
            // Update the head and link the last node to the new head
            last->next = temp->next; // Link last node to the second node
            *head = temp->next; // Update head to point to the new first node
            free(temp); // Free the old head
        }
        printf("Node deleted from position 0.\n");
        return;
    }

    // Traverse to find the node before the position to be deleted
    for (int i = 0; i < position - 1; i++) {
        temp = temp->next;
        if (temp->next == *head) { // If we reach back to head, position is out of bounds
            printf("Position exceeds the length of the list. Deletion failed.\n");
            return;
        }
    }

    // Now temp points to the node before the one to delete
    struct Node* toDelete = temp->next; // Node to be deleted
    temp->next = toDelete->next; // Link to the next node, skipping the toDelete node
    free(toDelete); // Free the memory of the node to delete

    printf("Node deleted from position %d.\n", position);
}

// Function to display the circular linked list
void displayList(struct Node* head) {
    if (head == NULL) {
        printf("The list is empty.\n");
        return;
    }
    
    struct Node* temp = head; // Temporary pointer to traverse the list
    printf("Circular Linked List: ");
    do {
        printf("%d -> ", temp->data); // Print current node's data
        temp = temp->next;             // Move to the next node
    } while (temp != head); // Loop until we return to the head
    printf("(head)\n"); // Indicate that we've looped back to the head
}

// Example usage
int main() {
    struct Node* head = NULL; // Initialize the head of the list

    // Insert elements into the circular linked list
    insertAtEnd(&head, 10);
    insertAtEnd(&head, 20);
    insertAtEnd(&head, 30);
    insertAtEnd(&head, 40);

    // Display the circular linked list
    displayList(head);

    // Delete a node at a specific position
    deleteAtPosition(&head, 2); // Delete node at position 2 (third node)
    displayList(head); // Display the list after deletion

    deleteAtPosition(&head, 0); // Delete node at position 0 (head)
    displayList(head); // Display the list after deletion

    deleteAtPosition(&head, 5); // Attempt to delete at an invalid position
    displayList(head); // Display the list after the invalid deletion attempt

    return 0;
}

output
Circular Linked List: 10 -> 20 -> 30 -> 40 -> (head)
Node deleted from position 2.
Circular Linked List: 10 -> 20 -> 40 -> (head)
Node deleted from position 0.
Circular Linked List: 20 -> 40 -> (head)
Position exceeds the length of the list. Deletion failed.
Circular Linked List: 20 -> 40 -> (head)
